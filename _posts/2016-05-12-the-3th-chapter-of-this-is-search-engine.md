---
layout:     post
title:      "这就是搜索引擎第三章-搜索引擎索引"
subtitle:   "这就是搜索引擎读书笔记"
date:       2016-05-17
author:     "秀川"
header-img: "img/post-bg-re-vs-ng2.jpg"
header-mask: 0.3
catalog:    true
tags:
    - 读书笔记
    - 《这就是搜索引擎》
    - 搜索
    - 搜索引擎索引
---

# 搜索引擎索引
索引在生活中是很常见的，比如书籍的目录。在搜索引擎中，索引是非常有用的数据结构，更是其中最重要的核心技术之一。

## 索引基础
#### 单词-文档矩阵
单词-文档矩阵是表达两者之间所具有的一种包含关系的概念模型，如图：
![单词-文档矩阵](../../../../img/in-post/0512/单词-文档矩阵.jpg "单词-文档矩阵")

搜索引擎的索引就是实现单词-文档矩阵的具体数据结构，可以用不同的方式来实现这个概念。

### 倒排索引基本概念

* 文档
以文本形式存在的存储对象

* 文档集合
由若干个文档组成的集合称为文档集合

* 文档编号
在索引引擎内部，会为文档集合中的每个文档赋予一个唯一的内部编号

* 单词编号
与文档编号类似，搜索引擎内部以唯一的编号来表示某个单词

* **倒排索引**（lexicon）
倒排索引是实现单词-文档矩阵的一种具体的存储形式。通过单词快速的获取包含这个单词的文档列表。倒排索引主要由两部分组成：**单词词典**和**倒排文件**。

* 单词词典
单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向倒排列表的指针。

* 倒排列表
倒排列表记载了出现过某个单词的所有文档的文档列表以及单词在该文档中出现的位置信息，每条记录称为倒排项

* 倒排文件
所有单词的倒排列表往往顺序的存储在磁盘的某个文件里面，这个文件即倒排文件，倒排文件是存储所有的物理文件。

![倒排文件基本概念](../../../../img/in-post/0512/倒排索引基本概念.jpg "倒排索引基本概念")

* 词频（TF）
某个单词在某个文档中出现的次数

* 文档频率
文档频率信息代表了文档集合中有多少个文档包含这个单词，他和词频一样，在搜索结果排序中有着非常重要的作用。

* 位置信息
单词在某个文档中出现的位置，这个信息在索引中可以选择不包含，因为加入位置信息以后索引会膨胀的很快。

## 单词词典
单词词典是倒排索引中非常重要的组成部分,用来维护文档集合中出现过的所有单词的相关信息，同时用于记载某个单词对应的倒排列表在倒排文件中的位置信息。

常用的数据结构：哈希加链表和树形词典结构。

### 哈希加链表
这种词典结构主要由哈希表以及冲突链表组成。每个哈希表项保存一个指针，指向冲突链表，在冲突链表里，相同哈希值的单词形成链表结构。

### 树形结构
B树（B+树）是另一种高效查找结构，B树与哈希方式查找不同，需要字典项能够按照大小排序（数字或者字符序），而哈希方式无须此要求。
下图是B树结构示意图：
![B树查找结构](../../../../img/in-post/0512/B树查找结构.jpg "B树查找结构")

B树形成了层级查找结构，中间节点用于支出一定顺序范围的词典项目存储在哪个子树种，起到根据词典项比较大小进行导航的作用，最底层的叶子节点存储单词的地址信息，根据这个地址就可以提取出单词字符串。

## 倒排列表
倒排列表用来记录有哪些文档包含了某个单词。一般文档集合里面会有很多文档包含某个单词，每个文档会记录文档编号（DocId），单词在这个文档中出现的次数（TF）及单词在文档中哪些位置出现过等信息，这样与一个文档相关的信息被称为倒排索引项，包含这个单词的一系列倒排索引项形成了倒排列表。

在实搜索引擎系统中，并不存储倒排索引项中的实际编号，而是代之以文档编号差值（要求倒排索引项按照由小到大排序，保证差值总是大于0的整数），这么做的主要原因是对数据进行压缩，增加数据的压缩率。

## 建立索引
建立索引比较实用的三种方法

### 两遍文档遍历法
两遍文档遍历法是完全使用内存建立索引的，其他两种方法都是需要内存与磁盘相互配合才可以建立索引。

第一遍扫描获取建立索引的一些统计信息，比如文档集合包含的文档个数，文档集合内所包含的不同单词个数，每个单词在多少文档中出现过的信息DF，把所有单词的DF值全部相加，就可以知道建立索引所需的内存大小是多少。然后在内存中分配足够大的连续存储区域，因为第一遍扫描已经获得了每个单词的DF信息，所以将连续存储区分成不同大小的片段，词典内某个单词根据自己对应的DF信息，可以通过指针，指向属于自己的内存片段的起始位置与终止位置。

第二遍扫描对每一个单词，获得包含这个单词的每个文档的文档id，词频信息，把这些信息不断的填充到第一遍扫描分配的内存空间中，当第二遍扫描结束的时候，分配的内存空间正好被填充满。

内存要求很大，因为要扫描两遍，索引速度上相比于其他两种也不占优势，在现实中这种方法并不常见。

### 排序法
在内存中分配固定大小的空间，用于存放词典信息以及索引的中间结果，当分配的中间结果被消耗完时，把中间结果写入磁盘上的临时文件，清空内存里中间结果所占的空间，以用做下一轮索引中间结果的存储区，这种方法由于只需要固定大小的内存，所以可以对任意大小的文档集合建立索引。
![排序法建索引](../../../../img/in-post/0512/排序法建索引.jpg "排序法建索引")

中间结果写入磁盘临时文件之前，需要对中间结果集（倒排项列表）进行按照单词ID，文档ID排序（有利于临时文件合并），排序完以后写入到临时文件中。当所有的文档都处理完成，在内存中对应临时文件的个数分配相应多的缓冲区，读入部分临时文件，将不同缓冲区中包含同一个单词的三元组（倒排项）进行合并，写入最终索引，同时将缓冲区中这个单词的三元组内容清空。三元组在临时文件中必须是有序的，这样才能够方便合并。

随着处理文档增多，词典所占用的内存也会越来越多，最后用于中间结果保存的空间就越来越少，处理速度就越来越慢。

### 归并法
归并法是排序法的升级版。也会在内存中开辟一块固定大小的内存存储中间结果，无论建立多大的索引都可以使用此方法来完成。当内存满了，就把中间结果写入磁盘临时文件，在排序法中，只有有序三元组（倒排项）信息是写入磁盘临时文件的，但是归并法会把词典信息以及三元组信息全部写入磁盘临时文件（中间结果应该也是有序的，方便后面归并），词典项放在列表最前端，之后跟随相应的倒排列表。

在归并法中的临时文件中存储的是完整的倒排索引信息。

## 动态索引
搜索引擎需要处理的文档都是动态文档，文档更新内容，文档被删除，新增文档，动态索引可以让索引系统如何做到实时反应，在这种动态索引中，有3个关键的索引结构：倒排索引，临时索引，已删除文档。

* 倒排索引
词典信息在内存，倒排列表存在磁盘文件中

* 临时索引
词典信息与倒排列表都存在内存中

* 已删除文档
已经删除的文档id的集合，修改的文档，相当于就文档删除，新增一个新的文档

用户查询的时候，搜索引擎同时从倒排索引和临时索引中读取用户查询单词的倒排列表，找到包含用户查询的文档集合，并对两个结果进行合并，之后利用已删除文档列表进行过滤，返回最终结果。

## 索引更新策略
由于内存的限制，需要将内存中的临时索引更新到磁盘中去，所以需要考虑索引更新策略。索引更新策略有4种：完全重建索引，再合并策略，原地更新策略，混合策略。

### 完全重建策略
当新增文档达到一定数量，将新增文档与原先的文档进行合并，按照之前介绍的建索引的方式建立索引，新索引建立完成后，老索引被遗弃。

因为重建索引时间比较长，索引在进行索引重建的过程中，老索引任然需要维护来对用户查询作出响应。这种完全重建索引的策略一般用于小文档，因为这种方式代价比较高。

### 再合并策略
当新增文档达到一定数量，临时索引与老文档的倒排索引进行合并。

再合并策略按照以下步骤进行索引内容更新：

* 当新增文档进入系统，解析文档，之后更新内存中维护的临时索引，文档中出现的每个单词，在其倒排列表末尾追加倒排列表项，这个临时索引可称为增量索引。
* 一旦增量索引将指定内存消耗完，此时需要一次索引合并，即增量索引与倒排索引内容进行合并。倒排索引与增量索引在遍历之前都需要按照字典序排序，这样对倒排文件的遍历只需要一遍，并且可以顺序读，减少了文件操作中比较耗时的磁盘寻道时间（这是再合并策略高效的原因）。

合并步骤如图：
![再合并策略](../../../../img/in-post/0512/再合并策略动态更新索引.jpg "再合并策略动态更新索引")

已经删除的索引还是存在的，这是再合并策略的一个缺点。

### 原地更新策略
增量索引达到一定的大小以后，在原来的倒排索引文件中做追加操作，将增量索引中的倒排列表项追加到老索引相应的位置末尾。

但是存在一个问题，倒排文件中的两个相邻单词，为了查询时加快速度，其倒排索引一般是顺序序列存储的，这导致了没有空余的位置用来追加信息，为了支持原地更新操作，每个单词的倒排列表后面会预留出一定的磁盘空间，在索引合并的时候可以将增量索引追加到预留空间中。

如果预留空间不足以容纳新增的倒排所以，那么会在磁盘中找到一块连续的存储区，之后把老的倒排列表读出并写入新的磁盘位置，并且增量索引的倒排列表项追加到后面。

原地更新策略效率比再合并策略低，主要有两方面的原因：
1. 对倒排列表的迁移是比较常见的操作，为了能进行快速迁移，而需要找到足够大的磁盘连续存储区，所以这个策略需要对磁盘可用空间进行维护和管理，而这种维护和查找的成本非常高
2. 由于原地更新策略对单词的倒排列表做数据迁移某些单词及其对应倒排列表会从老索引中移除，这样就破坏了这种单词的连续性，导致在进行索引合并时不能进行顺序读取，必须维护一个单词到其倒排列表文件相应位置的映射表，这样做一方面降低了磁盘读取数据，一方面需要大量的内存来存储这种映射关系。

### 混合策略
混合策略的出发点是能够结合不同索引更新策略的长处，将不同的索引更新策略混合，以形成高效的方法。

混合策略一般按照单词的不同性质分类，不同类别的单词，对其索引采取不同的索引更新策略。常见的做法是按照单词对应的倒排列表的长度进行区分，倒排列表长的单词采用原地更新策略（可以减少磁盘读写次数），倒排列表短的单词采用再合并策略

## 查询处理
查询处理主要是搜索引擎对于用户查询的处理过程，常见的查询处理机制，一种叫一次一文档方式，另一种叫一次一单词方法。还可以使用跳跃指针来查询优化过程。

### 一次一文档
搜索引擎接收到用户的查询后，解析出查询词，然后将查询词对应的倒排列表从磁盘读出，所谓一次一文档，就是每次把一个文档处理完成（最终相似性得分）再去处理下一个文档，以文档为单位。
![一次一文档](../../../../img/in-post/0512/一次一文档.jpg "一次一文档")

搜索系统的输出结果往往是限定个数的，在实际实现一次一文档方式时，不必保存所有文档的相关性得分，而只需要在内存中维护一个大小为K的优先级队列，用来保存目前计算过程中得分最高的K个文档即可，这样可以节省内存和计算时间。一般采取**根堆优先级队列**。

### 一次一单词
一次一文档是先纵向遍历单词文档矩阵，再横向遍历单词文档矩阵；但是一次一单词是先横向遍历单词文档矩阵，再纵向遍历单词文档矩阵。

处理完所有单词对应的倒排列表以，计算每个文档的相似性得分，之后按照得分大小排序，输出得分最高的K个文档。

![一次一单词](../../../../img/in-post/0512/一次一单词.jpg "一次一单词")

### 跳跃指针
跳跃指针的基本思想是将一个倒排列表的数据化整为零，切分为若干个大小固定的数据块，一个数据块为一组，对每个数据块，增加元信息来记录关于这个块的一些信息，这样即使面对压缩后的倒排列表在进行倒排列表合并的时候也可能有两个好处：一个好处是无须解压缩所有倒排列表项，只解压缩部分数据即可；另一个好处是无须比较任意两个文档id，通过这两种方式有效节省了计算资源和存储资源。

使用跳跃指针只要解压缩包含这个文档id的一段倒排列表接口，不需要解压缩所有的倒排列表。跳表如果数据块小，那么指针向后跳跃的可能性就大，增加了指针的比较次数；如果数据块大，可以有效减少指针比较次数，但是使用跳跃指针向后跳跃的可能性就变小，所以需要根据数据情况对块大小进行合理的设置才能取得最有结果。现实中的做法：***假设倒排列表长度为L，即包含L个文档ID，使用L的平方根做为块的大小***。

## 多字段索引
搜索关键词出现在不同字段的权重是不一样的，如果搜索关键词出现在网页标题，很明显这个网页的相关性会高于只在正文中出现关键词的网页，所以区分不同字段对于搜索引擎的相关性评分也有很大的作用。

搜索引擎需要对多字段进行索引，而实现多字段索引有三种方式：多索引方式，倒排列表方式，扩展列表方式。

### 多索引方式
多索引方式针对每个字段分别建立一个索引，用户指定某个字段做为搜索范围时，可以从相应的索引里提取结果。

如果用户没有指定特定的字段，搜索引擎会对所有字段进行查找并合并多个字段的相关性得分，对于多索引方式来说，就需要对多个索引进行读取，索引这种方式效率会比较低。

### 倒排列表
为了支持字段搜索，也可以把字段信息存储在某个关键词对应的倒排列表内，在倒排列表中每个文档索引项信息的末尾追加字段信息，这样在读出用户查询关键词的倒排列表的同时，就可以根据字段信息，判断这个关键词是否在某个字段中出现，以此来进行过滤，并保留指定志短内出现过搜索词的文档做为搜索结果。

### 扩展列表方式
扩展列表是实际中用的比较多的支持多字段索引的方法。这个方法为每个字段建立一个列表，这个列表记载了这个字段在每个文档中出现的对应位置信息。
![扩展列表方式](../../../../img/in-post/0512/扩展列表方式.jpg "扩展列表方式")

## 短语查询
短语查询强调单词之间的顺序。如果单词的倒排列表只存储文档编号以及单词频率信息，其爆了的信息是不足以支持短语搜索的，因为单词之间的顺序关系没有保留。常见的支持短语查询技术方法：位置信息索引，双词索引，短语索引。

### 位置信息索引
我们一般不存储位置信息，因为加入位置信息这样会使倒排列表长度剧烈增加，消耗很多内存，另外还影响读取效率，对快速响应用户查询不利。但是如果加上位置信息，可以很方便的支持短语查询。

### 双词索引
双词索引是另一种可以对短语查询提供支持的索引结构。短语至少两个单词，也可能包含多个单词，统计数据表明，二词短语在短语中所占比例最大，如果能针对二词短语提供快速查询，也能解决短语查询问题。

双词索引会使数据量急剧增大，词典结构是一维的，而双词索引是二维的，这样倒排列表会急剧增大，所以一般并非对所有的单词建立双词索引，而只是对计算代价高的短语建双词索引。

### 短语索引
短语索引就是直接在索引中加入短语索引，但是不可能事先将所有的短语都建好，通用的做法是挖掘出热门短语，为这些短语专门建立索引。

加入短语索引以后，搜索引擎接收到用户的查询后，首先在短语索引里查找，如果找到，则计算后返回给用户搜索结果，否则任然利用常规索引进行查询处理。

![短语索引](../../../../img/in-post/0512/短语索引.jpg "短语索引")

### 混合方法
位置索引适合处理常规的短语查询，即计算代价小的短语；双词索引适合处理计算代价较高的短语查询；短语索引适合处理热门短语查询或者文本中高频度出现的短语。如果这三种索引能够有机的集成在一起，就可以使系统返回出很大优势。

![混合索引](../../../../img/in-post/0512/混合索引.jpg "混合索引")

## 分布式索引
当搜索引擎需要处理的文档集合数量非常庞大时，靠单机往往难以承担如此重任，此时需要考虑分布式解决方案。每台机器维护整个索引的一部分，由多机写作来完成索引的建立和对查询的响应。分布式索引方案有两种：按文档对索引划分和按单词对索引划分。

### 按文档划分
按文档划分就是将整个文档集合切割成若干个子集，每台机器负责对某个文档子集建立索引，并响应查询请求。查询分发服务器接收到查询请求以后将查询广播给所有索引服务器，每个索引服务器负责部分文档子集的索引维护和查询响应，当索引服务器接收到用户查询之后，按照计算相关文档的得分，返回得分最高的K个文档给分发服务器，分发服务器拿到各个索引服务器的搜索结果后，合并结果并返回。
![文档划分方式对用户查询的响应](../../../../img/in-post/0512/按照文档分布式.jpg "按照文档分布式")

### 按单词划分
按单词划分是对单词词典进行划分，每个索引服务器负责词典中部分单词的倒排列表的建立和维护。某个单词的查询只能在某台服务器下面完成。

按单词划分扩展性差，负载均衡也不是很好，容错性差对查询处理方式的支持不够灵活，所以按文档划分对于索引的分布式来说是比较好的选择







